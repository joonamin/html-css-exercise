# what happens?

- block box type을 사용한다면 '영역'을 차지하여 '길막'을 하기 때문에 `가로배치가 어렵다`

  - 이를 해결해주기 위해서 등장한 것이 `float`
  - 사용할 경우, 어떤 일이 발생하는 지? (what happens)
    - 가로 배치를 성공하게 만들어주지만 레이아웃을 얼마나 망가뜨리는지
  - 어떻게 망가진 레이아웃을 복구할 수 있는지? (how to fix it)

- float를 사용하면 부모요소에게 붙어있는 자식 요소가 띄워진다.

  - float를 사용한 자식 요소는 부모요소가 "집 나간 자식" 취급을 하게 됨
    - remind: block box의 부모요소의 height값은 명시적으로 지정해주지 않는 경우 자식 요소들의 height의 합이다.
    - 부모가 가진 자식 요소가 float로 지정되게 될 경우, 해당 자식 요소가 차지하는 공간은 `빈 공간` 취급을 하게 된다.
    * 즉, 모든 자식 요소가 float로 지정될 경우 부모의 height는 0이 된다.

- 특정 요소를 float로 지정할 경우 `Block` 으로 취급한다.

  - inline, inline block, block -> block
  - 하지만, 블록인데 `길막`을 못한다!!
    - 약간 하자가 있는 블록... ㅜ
    - remind: 블록에서는 따로 width를 선언하지 않는 경우
      - width = 부모의 content-box의 100%
  - 실제 컨텐츠의 크기를 가진 상태로 "붕 뜬 상태"가 된다.
    - 늘어나되, 영역을 전부 차지하는 `block`과는 느낌이 다르다.

- block에서는 width를 지정한다면, content 크기 외의 남는 크기는 margin으로 처리된다.
  - **하지만, float에서는 이러한 일이 발생하지 않는다**
  - margin 값 자체는 줄 수 있다. 하지만, 자동으로 처리되지는 않는다.

* `float: left`는 요소를 띄운 다음에, 배치 가능한 영역중 가장 왼쪽에 배치하는 것을 의미한다.

  - 이렇게 띄워진 요소들은 부모의 영향에서 벗어난다.
  - float가 적용되지 않는 요소들은 float가 적용된 요소들을 신경쓰지 않고, 빈 공간에 순차적으로 배치되게 된다.

* `block` 요소는 float 요소에 대한 유무를 잘 알지못한다.
  - 그래서, 요소를 배치할 때 영역을 침범하는 일이 발생
  - **하지만, inline 요소는 float 요소의 유무를 잘 안다**
    - 그래서, float된 요소를 피해서 inline 요소들이 배치된다.

**_float를 하면 가로배치는 시킬 수 있지만, 레이아웃을 망치는 주범이다_**

<details>
  <summary> 요약 </summary>
  <ul>
  <li> 집 나간 내 새끼, 찾을 길 없네 </li>
  <li> 블록으로 신분 상승 </li>
  <li> 길막을 못해 슬픈 블록아 </li>
  <li> 플로트, 나만 볼 수 있어요 (feat. 인라인) </li>
</ul>
</details>

# how to fix it?

- float가 레이아웃을 망치는 것은 알겠다. 그러면 어떻게 수정하는 것이 적절할까?
- 가장 쉬운 방법은 부모 요소에 `overflow: hidden` 을 추가한다.

  - 이 경우, 부모 요소가 float의 존재를 알 수 있게된다. (그냥 기억하자..)
  - 무조건적으로 이 방법을 사용하는 것은 지양하자

- `clearfix` 를 이용한 방법
  - `clear` property를 이용한 해결 방법!!
  - **오로지 float로 인해 망가진 레이아웃을 복구하기 위해서 사용**
  - `clear: left` 를 적용할 경우, `float: left` 를 적용한 요소들의 존재를 알 수 있게된다.
    - 그 결과로, block 요소는 배치하기 충분하지 않은 영역에 대해서 다음 칸으로 이동하게 된다.
    - 부모 요소는 block 요소의 위치를 통해서 전체 자식들을 유추할 수 있다.
      - 그 결과로, parent의 height는 float된 요소의 height까지 고려할 수 있게되는 것이다.
  - `clear` 는 `left, right, both` 값을 가질 수 있다.
    - 각각에 대해서 `float: {left | right}` 요소들에 대해서 영향을 받지 않겠다고 선언하는 것과 같다.
  - 💡 그렇다면, float된 요소들의 레이아웃을 보존하기 위해서 아무의미없는 block 요소 (ex. div)를 삽입하여 부모 요소가 레이아웃을 잡는 것에 도움을 줘야할까?
    - 가능은 하지만, 이것은 레이아웃을 위해서 아무런 의미가 없는 태그를 삽입하는 것이고, html의 의미를 떨어뜨리게된다.

* css의 `pseudo element` 기능을 활용한 방법
  - css에 fake-element를 주고 clear를 먹이는 방법
  * **각 요소당 최대 2개씩 만들 수 있다**
    - `::before`, `::after`
    - `block` 요소에만 `clear` 를 지정할 수 있음!!
      - 반드시 `block 계열`의 box model을 사용
    - 각각은 `content` 프로퍼티를 반드시 채워주어야함
    - 해당 요소는 `inline` 요소로 작용하게 됨
